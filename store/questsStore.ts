'use client'

import { create } from 'zustand'
import { completeQuest as completeQuestRemote, fetchQuests, createQuest as createQuestRemote } from '@/lib/quests'
import { Quest, QuestStatus } from '@/components/quests/QuestFormModal'
import { usePlayerStore } from './playerStore'
import { useQuestMetadataStore, QuestMetadata } from './questMetadataStore'

type QuestsState = {
  quests: Quest[]
  hydrated: boolean
  hydrate: () => Promise<void>
  setQuests: (updater: (prev: Quest[]) => Quest[]) => void
  addQuest: (quest: Quest) => Promise<void> // Changed to async for API call
  updateQuest: (questId: string, updater: (quest: Quest) => Quest) => void
  deleteQuest: (questId: string) => void
  toggleStatus: (questId: string) => void
  toggleTopPriority: (questId: string) => void
  markQuestCompleted: (questId: string) => void
  completeQuest: (questId: string) => Promise<void>
}

// Helper to merge API data with Local Metadata
const mergeWithMetadata = (apiQuest: any, metadata: QuestMetadata | undefined): Quest => {
  return {
    id: apiQuest.id,
    title: apiQuest.title,
    // Prefer metadata if available, else fall back to API (which might be null/empty for these fields now)
    description: metadata?.description ?? apiQuest.description ?? undefined,
    difficulty: metadata?.difficulty ?? (apiQuest.difficulty as Quest['difficulty']) ?? 'NORMAL',
    status: (apiQuest.status as QuestStatus) ?? 'TODO',
    dueAt: apiQuest.due_at ? new Date(apiQuest.due_at) : undefined,
    isCompleted: apiQuest.is_completed ?? apiQuest.status === 'COMPLETED',
    completedAt: apiQuest.completed_at ? new Date(apiQuest.completed_at) : undefined,
    plannedMinutes: metadata?.plannedMinutes ?? apiQuest.planned_minutes ?? 25,
    isDaily: metadata?.isDaily ?? apiQuest.is_daily ?? false,
    isUrgent: metadata?.isUrgent ?? apiQuest.is_urgent ?? false,
    isTopPriority: metadata?.isTopPriority ?? apiQuest.is_top_priority ?? false,
    timerColor: metadata?.timerColor ?? (apiQuest.timer_color as Quest['timerColor']) ?? 'red',
    xpReward: metadata?.xpReward ?? apiQuest.xp_reward ?? 0,
  }
}

export const useQuestsStore = create<QuestsState>((set, get) => ({
  quests: [],
  hydrated: false,

  hydrate: async () => {
    // Always fetch to get latest status, even if hydrated before (for simple sync)
    const records = await fetchQuests()
    const metadataStore = useQuestMetadataStore.getState()

    // Sync Metadata Store: Remove keys that are not in the fetched records (cleanup deleted quests)
    const validIds = records.map(r => r.id)
    metadataStore.resync(validIds)

    const quests: Quest[] = records.map((r) => {
      const meta = metadataStore.getMetadata(r.id)
      return mergeWithMetadata(r, meta)
    })

    set({ quests, hydrated: true })
  },

  setQuests: (updater) => set((state) => ({ quests: updater(state.quests) })),

  addQuest: async (quest) => {
    // 1. Call API with minimal payload (handled by createQuestRemote/API route now)
    // We pass the full quest object, but the API handler (route.ts) will pick what it needs.
    // However, we need the ID generated by the DB.

    try {
      const newQuestRecord = await createQuestRemote(quest)

      // 2. Save extended metadata to Local Storage
      const metadata: QuestMetadata = {
        xpReward: quest.xpReward,
        difficulty: quest.difficulty,
        description: quest.description,
        plannedMinutes: quest.plannedMinutes,
        isDaily: quest.isDaily,
        isUrgent: quest.isUrgent,
        isTopPriority: quest.isTopPriority,
        timerColor: quest.timerColor
      }
      useQuestMetadataStore.getState().setMetadata(newQuestRecord.id, metadata)

      // 3. Merge and update local state
      const mergedQuest = mergeWithMetadata(newQuestRecord, metadata)

      set((state) => ({ quests: [...state.quests, mergedQuest] }))
    } catch (error) {
      console.error("Failed to add quest:", error)
      // Optionally handle error UI
    }
  },

  updateQuest: (questId, updater) => {
    set((state) => {
      const currentQuest = state.quests.find(q => q.id === questId)
      if (!currentQuest) return state

      const updatedQuest = updater(currentQuest)

      // Update Metadata
      const metadata: QuestMetadata = {
        xpReward: updatedQuest.xpReward,
        difficulty: updatedQuest.difficulty,
        description: updatedQuest.description,
        plannedMinutes: updatedQuest.plannedMinutes,
        isDaily: updatedQuest.isDaily,
        isUrgent: updatedQuest.isUrgent,
        isTopPriority: updatedQuest.isTopPriority,
        timerColor: updatedQuest.timerColor
      }
      useQuestMetadataStore.getState().setMetadata(questId, metadata)

      return {
        quests: state.quests.map((quest) => (quest.id === questId ? updatedQuest : quest)),
      }
    })
  },

  deleteQuest: (questId) => {
    // Note: We should technically call an API to delete remote too, 
    // but for now we just handle local state + metadata
    useQuestMetadataStore.getState().removeMetadata(questId)

    set((state) => ({
      quests: state.quests.filter((quest) => quest.id !== questId),
    }))
  },

  toggleStatus: (questId) =>
    set((state) => ({
      quests: state.quests.map((quest) =>
        quest.id === questId
          ? {
            ...quest,
            status: quest.status === 'COMPLETED' ? 'TODO' : ('COMPLETED' as QuestStatus),
            isCompleted: quest.status !== 'COMPLETED',
          }
          : quest
      ),
    })),

  toggleTopPriority: (questId) =>
    set((state) => ({
      quests: state.quests.map((quest) =>
        quest.id === questId ? { ...quest, isTopPriority: !quest.isTopPriority } : quest
      ),
    })),

  markQuestCompleted: (questId) =>
    set((state) => ({
      quests: state.quests.map((quest) =>
        quest.id === questId
          ? { ...quest, status: 'COMPLETED' as QuestStatus, isCompleted: true }
          : quest
      ),
    })),

  completeQuest: async (questId) => {
    // Get XP from local state (which is already merged with metadata)
    const targetQuest = get().quests.find(q => q.id === questId)
    // Fallback to 20 if 0 or undefined, as per new "Fixed 20 XP" rule, 
    // unless explicitly 0 means something else. But user wants 5 quests = 1 level.
    const xp = (targetQuest?.xpReward && targetQuest.xpReward > 0) ? targetQuest.xpReward : 20

    console.log('[completeQuest] Completing quest:', questId, 'XP Reward:', xp, 'QuestObj:', targetQuest)

    await completeQuestRemote(questId)

    if (xp > 0) {
      console.log('[completeQuest] Adding XP to player store:', xp)
      usePlayerStore.getState().addExp(xp)
    }

    set((state) => ({
      quests: state.quests.map((quest) =>
        quest.id === questId
          ? { ...quest, status: 'COMPLETED' as QuestStatus, isCompleted: true }
          : quest
      ),
    }))
  },
}))
